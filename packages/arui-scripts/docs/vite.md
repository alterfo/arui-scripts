Использование vite
===

На данный момент arui-scripts поддерживает использование vite только в качестве dev-инструмента - production сборки
с его помощью не собираются.

## Как работает
Костыли и магия!
Ну а если серьезно:
1. Сервер по прежнему собирается вебпаком
2. Создается отдельный express сервер на 8080, в него подключается vite middleware
3. Если запрос идет за кодом - его обрабатывает сам vite. В противном случае:
   1. На запросы за /assets/webpack-assets.json генерируется фейковый webpack-assets так, как его бы генерировал вебпак
   2. На запросы за статикой, которую билд сервера сложил в .build/assets пытаемся отвечать контентом из файловой системы
   3. На запросы за html - обращаемся к серверу приложения на 3000. Извлекаем из vite список скриптов, которые надо вставить на страницу
   и подменяем ответ вашего сервера, дополняя его нужными скриптами
   4. Остальные запросы просто прокидываем до сервера вашего приложения.

## Известные проблемы

Знания на просторах интернета: https://github.com/originjs/webpack-to-vite

То, с чем столкнулся я:

- Импорт `@alfalab/core-components/vars` из css будет падать. Замените на `@alfalab/core-components/vars/index.css`
- Не будет работать `require`. Если вы где то писали `require('./random-file.pdf')` - пришло время заменить его на нормальный import.
- Естественно не работают оверрайды, которые вы применяли к вебпаку. Если вы активно их использовали или добавляли оверрайды для вебпака
через пресеты - это придется переделывать. То же относится и к dev-server, babel-client.
- `No matching export for import typescript interface` - если вы делаете реэкспорт типов в своем коде - придется его заменить на export type.
```ts
import { SomeType } from './types';
export { SomeType } // так работать не будет!
export type { SomeType } // вот так - норм.
```
Вы можете починить это правилом для eslint `"@typescript-eslint/consistent-type-imports": ["error", { "fixStyle": "inline-type-imports"}]`.
Оно уже включено в последней версии arui-presets-lint.
